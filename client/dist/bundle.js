/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/js/app.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js?!./src/css/main.less":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js??ref--5-2!./src/css/main.less ***!
  \******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\")(false);\n// Module\nexports.push([module.i, \"body,html{overflow:hidden;position:fixed;width:100%;height:100%;margin:0;padding:0;text-align:center}.wrapper{margin:0 auto;position:relative}.wrapper .page{display:flex;flex-direction:column;justify-content:center;position:absolute;width:100%;height:100%}.wrapper .page h1.title{margin-top:0;color:#fff;text-align:center}.wrapper .page .button{color:#fff;font-size:1.5rem}.wrapper canvas{-webkit-tap-highlight-color:transparent;background:#000}\", \"\"]);\n\n\n//# sourceURL=webpack:///./src/css/main.less?./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js??ref--5-2");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return \"@media \".concat(item[2], \"{\").concat(content, \"}\");\n      }\n\n      return content;\n    }).join('');\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery) {\n    if (typeof modules === 'string') {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, '']];\n    }\n\n    var alreadyImportedModules = {};\n\n    for (var i = 0; i < this.length; i++) {\n      // eslint-disable-next-line prefer-destructuring\n      var id = this[i][0];\n\n      if (id != null) {\n        alreadyImportedModules[id] = true;\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = modules[_i]; // skip already imported module\n      // this implementation is not 100% perfect for weird media query combinations\n      // when a module is imported multiple times with different media queries.\n      // I hope this will never occur (Hey this way we have smaller bundles)\n\n      if (item[0] == null || !alreadyImportedModules[item[0]]) {\n        if (mediaQuery && !item[2]) {\n          item[2] = mediaQuery;\n        } else if (mediaQuery) {\n          item[2] = \"(\".concat(item[2], \") and (\").concat(mediaQuery, \")\");\n        }\n\n        list.push(item);\n      }\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring\n\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === 'function') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot).concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n  }\n\n  return [content].join('\\n');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n  return \"/*# \".concat(data, \" */\");\n}\n\n//# sourceURL=webpack:///./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/neffos.js/dist/neffos.js":
/*!***********************************************!*\
  !*** ./node_modules/neffos.js/dist/neffos.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {var __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\n// Make it compatible to run with browser and inside nodejs\r\n// the good thing is that the node's WebSocket module has the same API as the browser's one,\r\n// so all works and minimum changes were required to achieve that result.\r\n// See the `genWait()` too.\r\nvar isBrowser = (typeof window !== 'undefined');\r\nvar _fetch = (typeof fetch !== 'undefined') ? fetch : undefined;\r\nif (!isBrowser) {\r\n    WebSocket = __webpack_require__(/*! ws */ \"./node_modules/neffos.js/node_modules/ws/browser.js\");\r\n    _fetch = __webpack_require__(/*! node-fetch */ \"./node_modules/node-fetch/browser.js\");\r\n}\r\nelse {\r\n    WebSocket = window[\"WebSocket\"];\r\n}\r\n/* The OnNamespaceConnect is the event name that it's fired on before namespace connect. */\r\nvar OnNamespaceConnect = \"_OnNamespaceConnect\";\r\n/* The OnNamespaceConnected is the event name that it's fired on after namespace connect. */\r\nvar OnNamespaceConnected = \"_OnNamespaceConnected\";\r\n/* The OnNamespaceDisconnect is the event name that it's fired on namespace disconnected. */\r\nvar OnNamespaceDisconnect = \"_OnNamespaceDisconnect\";\r\n/* The OnRoomJoin is the event name that it's fired on before room join. */\r\nvar OnRoomJoin = \"_OnRoomJoin\";\r\n/* The OnRoomJoined is the event name that it's fired on after room join. */\r\nvar OnRoomJoined = \"_OnRoomJoined\";\r\n/* The OnRoomLeave is the event name that it's fired on before room leave. */\r\nvar OnRoomLeave = \"_OnRoomLeave\";\r\n/* The OnRoomLeft is the event name that it's fired on after room leave. */\r\nvar OnRoomLeft = \"_OnRoomLeft\";\r\n/* The OnAnyEvent is the event name that it's fired, if no incoming event was registered, it's a \"wilcard\". */\r\nvar OnAnyEvent = \"_OnAnyEvent\";\r\n/* The OnNativeMessage is the event name, which if registered on empty (\"\") namespace\r\n   it accepts native messages(Message.Body and Message.IsNative is filled only). */\r\nvar OnNativeMessage = \"_OnNativeMessage\";\r\nvar ackBinary = 'M'; // see `onopen`, comes from client to server at startup.\r\n// see `handleAck`.\r\nvar ackIDBinary = 'A'; // comes from server to client after ackBinary and ready as a prefix, the rest message is the conn's ID.\r\nvar ackNotOKBinary = 'H'; // comes from server to client if `Server#OnConnected` errored as a prefix, the rest message is the error text.\r\nvar waitIsConfirmationPrefix = '#';\r\nvar waitComesFromClientPrefix = '$';\r\n/* The isSystemEvent reports whether the \"event\" is a system event;\r\nconnect, connected, disconnect, room join, room joined, room leave, room left. */\r\nfunction isSystemEvent(event) {\r\n    switch (event) {\r\n        case OnNamespaceConnect:\r\n        case OnNamespaceConnected:\r\n        case OnNamespaceDisconnect:\r\n        case OnRoomJoin:\r\n        case OnRoomJoined:\r\n        case OnRoomLeave:\r\n        case OnRoomLeft:\r\n            return true;\r\n        default:\r\n            return false;\r\n    }\r\n}\r\nfunction isEmpty(s) {\r\n    if (s === undefined) {\r\n        return true;\r\n    }\r\n    if (s === null) {\r\n        return true;\r\n    }\r\n    if (s == \"\" || typeof s === 'string' || s instanceof String) {\r\n        return s.length === 0 || s === \"\";\r\n    }\r\n    if (s instanceof Error) {\r\n        return isEmpty(s.message);\r\n    }\r\n    return false;\r\n}\r\n/* The Message is the structure which describes the icoming data (and if `Conn.Write` is manually used to write). */\r\nvar Message = /** @class */ (function () {\r\n    function Message() {\r\n    }\r\n    /* The SetBinary can be filled to true if the client must send this message using the Binary format message.\r\n       This field is not filled on sending/receiving. */\r\n    // SetBinary: boolean;\r\n    Message.prototype.isConnect = function () {\r\n        return this.Event == OnNamespaceConnect || false;\r\n    };\r\n    Message.prototype.isDisconnect = function () {\r\n        return this.Event == OnNamespaceDisconnect || false;\r\n    };\r\n    Message.prototype.isRoomJoin = function () {\r\n        return this.Event == OnRoomJoin || false;\r\n    };\r\n    Message.prototype.isRoomLeft = function () {\r\n        return this.Event == OnRoomLeft || false;\r\n    };\r\n    Message.prototype.isWait = function () {\r\n        if (isEmpty(this.wait)) {\r\n            return false;\r\n        }\r\n        if (this.wait[0] == waitIsConfirmationPrefix) {\r\n            return true;\r\n        }\r\n        return this.wait[0] == waitComesFromClientPrefix || false;\r\n    };\r\n    /* unmarshal method returns this Message's `Body` as an object,\r\n       equivalent to the Go's `neffos.Message.Unmarshal` method.\r\n       It can be used inside an event's callbacks.\r\n       See library-level `marshal` function too. */\r\n    Message.prototype.unmarshal = function () {\r\n        return JSON.parse(this.Body);\r\n    };\r\n    return Message;\r\n}());\r\n/* marshal takes an object and returns its serialized to string form, equivalent to the Go's `neffos.Marshal`.\r\n   It can be used on `emit` methods.\r\n   See `Message.unmarshal` method too. */\r\nfunction marshal(obj) {\r\n    return JSON.stringify(obj);\r\n}\r\n/* Obsiously, the below should match the server's side. */\r\nvar messageSeparator = ';';\r\nvar messageFieldSeparatorReplacement = \"@%!semicolon@%!\";\r\nvar validMessageSepCount = 7;\r\nvar trueString = \"1\";\r\nvar falseString = \"0\";\r\nvar escapeRegExp = new RegExp(messageSeparator, \"g\");\r\nfunction escapeMessageField(s) {\r\n    if (isEmpty(s)) {\r\n        return \"\";\r\n    }\r\n    return s.replace(escapeRegExp, messageFieldSeparatorReplacement);\r\n}\r\nvar unescapeRegExp = new RegExp(messageFieldSeparatorReplacement, \"g\");\r\nfunction unescapeMessageField(s) {\r\n    if (isEmpty(s)) {\r\n        return \"\";\r\n    }\r\n    return s.replace(unescapeRegExp, messageSeparator);\r\n}\r\nvar replyError = /** @class */ (function (_super) {\r\n    __extends(replyError, _super);\r\n    function replyError(message) {\r\n        var _this = _super.call(this, message) || this;\r\n        _this.name = 'replyError';\r\n        Error.captureStackTrace(_this, replyError);\r\n        // Set the prototype explicitly,\r\n        // see `isReply`'s comments for more information.\r\n        Object.setPrototypeOf(_this, replyError.prototype);\r\n        return _this;\r\n    }\r\n    return replyError;\r\n}(Error));\r\n/* reply function is a helper for nsConn.Emit(incomignMsg.Event, newBody)\r\n   it can be used as a return value of any MessageHandlerFunc. */\r\nfunction reply(body) {\r\n    return new replyError(body);\r\n}\r\nfunction isReply(err) {\r\n    // unfortunately this doesn't work like normal ES6,\r\n    // typescript has an issue:\r\n    // https://github.com/Microsoft/TypeScript/issues/22585\r\n    // https://github.com/Microsoft/TypeScript/issues/13965\r\n    // hack but doesn't work on IE 10 and prior, we can adapt it\r\n    // because the library itself is designed for modern browsers instead.\r\n    //\r\n    // https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-extending-built-ins-like-error-array-and-map-work\r\n    return (err instanceof replyError);\r\n}\r\nfunction serializeMessage(msg) {\r\n    if (msg.IsNative && isEmpty(msg.wait)) {\r\n        return msg.Body;\r\n    }\r\n    var isErrorString = falseString;\r\n    var isNoOpString = falseString;\r\n    var body = msg.Body || \"\";\r\n    if (!isEmpty(msg.Err)) {\r\n        body = msg.Err.message;\r\n        if (!isReply(msg.Err)) {\r\n            isErrorString = trueString;\r\n        }\r\n    }\r\n    if (msg.isNoOp) {\r\n        isNoOpString = trueString;\r\n    }\r\n    return [\r\n        msg.wait || \"\",\r\n        escapeMessageField(msg.Namespace),\r\n        escapeMessageField(msg.Room),\r\n        escapeMessageField(msg.Event),\r\n        isErrorString,\r\n        isNoOpString,\r\n        body\r\n    ].join(messageSeparator);\r\n}\r\n// behaves like Go's SplitN, default javascript's does not return the remainder and we need this for the dts[6]\r\nfunction splitN(s, sep, limit) {\r\n    if (limit == 0)\r\n        return [s];\r\n    var arr = s.split(sep, limit);\r\n    if (arr.length == limit) {\r\n        var curr = arr.join(sep) + sep;\r\n        arr.push(s.substr(curr.length));\r\n        return arr;\r\n    }\r\n    else {\r\n        return [s];\r\n    }\r\n}\r\n// <wait>;\r\n// <namespace>;\r\n// <room>;\r\n// <event>;\r\n// <isError(0-1)>;\r\n// <isNoOp(0-1)>;\r\n// <body||error_message>\r\nfunction deserializeMessage(data, allowNativeMessages) {\r\n    var msg = new Message();\r\n    if (data.length == 0) {\r\n        msg.isInvalid = true;\r\n        return msg;\r\n    }\r\n    var dts = splitN(data, messageSeparator, validMessageSepCount - 1);\r\n    if (dts.length != validMessageSepCount) {\r\n        if (!allowNativeMessages) {\r\n            msg.isInvalid = true;\r\n        }\r\n        else {\r\n            msg.Event = OnNativeMessage;\r\n            msg.Body = data;\r\n        }\r\n        return msg;\r\n    }\r\n    msg.wait = dts[0];\r\n    msg.Namespace = unescapeMessageField(dts[1]);\r\n    msg.Room = unescapeMessageField(dts[2]);\r\n    msg.Event = unescapeMessageField(dts[3]);\r\n    msg.isError = dts[4] == trueString || false;\r\n    msg.isNoOp = dts[5] == trueString || false;\r\n    var body = dts[6];\r\n    if (!isEmpty(body)) {\r\n        if (msg.isError) {\r\n            msg.Err = new Error(body);\r\n        }\r\n        else {\r\n            msg.Body = body;\r\n        }\r\n    }\r\n    else {\r\n        msg.Body = \"\";\r\n    }\r\n    msg.isInvalid = false;\r\n    msg.IsForced = false;\r\n    msg.IsLocal = false;\r\n    msg.IsNative = (allowNativeMessages && msg.Event == OnNativeMessage) || false;\r\n    // msg.SetBinary = false;\r\n    return msg;\r\n}\r\nfunction genWait() {\r\n    if (!isBrowser) {\r\n        var hrTime = process.hrtime();\r\n        return waitComesFromClientPrefix + hrTime[0] * 1000000000 + hrTime[1];\r\n    }\r\n    else {\r\n        var now = window.performance.now();\r\n        return waitComesFromClientPrefix + now.toString();\r\n    }\r\n}\r\nfunction genWaitConfirmation(wait) {\r\n    return waitIsConfirmationPrefix + wait;\r\n}\r\nfunction genEmptyReplyToWait(wait) {\r\n    return wait + messageSeparator.repeat(validMessageSepCount - 1);\r\n}\r\n/* The Room describes a connected connection to a room,\r\n   emits messages with the `Message.Room` filled to the specific room\r\n   and `Message.Namespace` to the underline `NSConn`'s namespace. */\r\nvar Room = /** @class */ (function () {\r\n    function Room(ns, roomName) {\r\n        this.nsConn = ns;\r\n        this.name = roomName;\r\n    }\r\n    /* The emit method sends a message to the server with its `Message.Room` filled to this specific room\r\n       and `Message.Namespace` to the underline `NSConn`'s namespace. */\r\n    Room.prototype.emit = function (event, body) {\r\n        var msg = new Message();\r\n        msg.Namespace = this.nsConn.namespace;\r\n        msg.Room = this.name;\r\n        msg.Event = event;\r\n        msg.Body = body;\r\n        return this.nsConn.conn.write(msg);\r\n    };\r\n    /* The leave method sends a local and server room leave signal `OnRoomLeave`\r\n       and if succeed it fires the OnRoomLeft` event. */\r\n    Room.prototype.leave = function () {\r\n        var msg = new Message();\r\n        msg.Namespace = this.nsConn.namespace;\r\n        msg.Room = this.name;\r\n        msg.Event = OnRoomLeave;\r\n        return this.nsConn.askRoomLeave(msg);\r\n    };\r\n    return Room;\r\n}());\r\n/* The NSConn describes a connected connection to a specific namespace,\r\n   it emits with the `Message.Namespace` filled and it can join to multiple rooms.\r\n   A single Conn can be connected to one or more namespaces,\r\n   each connected namespace is described by this class. */\r\nvar NSConn = /** @class */ (function () {\r\n    function NSConn(conn, namespace, events) {\r\n        this.conn = conn;\r\n        this.namespace = namespace;\r\n        this.events = events;\r\n        this.rooms = new Map();\r\n    }\r\n    /* The emit method sends a message to the server with its `Message.Namespace` filled to this specific namespace. */\r\n    NSConn.prototype.emit = function (event, body) {\r\n        var msg = new Message();\r\n        msg.Namespace = this.namespace;\r\n        msg.Event = event;\r\n        msg.Body = body;\r\n        return this.conn.write(msg);\r\n    };\r\n    /* See `Conn.ask`. */\r\n    NSConn.prototype.ask = function (event, body) {\r\n        var msg = new Message();\r\n        msg.Namespace = this.namespace;\r\n        msg.Event = event;\r\n        msg.Body = body;\r\n        return this.conn.ask(msg);\r\n    };\r\n    /* The joinRoom method can be used to join to a specific room, rooms are dynamic.\r\n       Returns a `Room` or an error. */\r\n    NSConn.prototype.joinRoom = function (roomName) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.askRoomJoin(roomName)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /* The room method returns a joined `Room`. */\r\n    NSConn.prototype.room = function (roomName) {\r\n        return this.rooms.get(roomName);\r\n    };\r\n    // Rooms(): Room[] {\r\n    //     let rooms = new Array<Room>(this.rooms.size);\r\n    //     this.rooms.forEach((room) => {\r\n    //         rooms.push(room);\r\n    //     })\r\n    //     return rooms;\r\n    // }\r\n    /* The leaveAll method sends a leave room signal to all rooms and fires the `OnRoomLeave` and `OnRoomLeft` (if no error occurred) events. */\r\n    NSConn.prototype.leaveAll = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var leaveMsg;\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                leaveMsg = new Message();\r\n                leaveMsg.Namespace = this.namespace;\r\n                leaveMsg.Event = OnRoomLeft;\r\n                leaveMsg.IsLocal = true;\r\n                this.rooms.forEach(function (value, roomName) { return __awaiter(_this, void 0, void 0, function () {\r\n                    var err_1;\r\n                    return __generator(this, function (_a) {\r\n                        switch (_a.label) {\r\n                            case 0:\r\n                                leaveMsg.Room = roomName;\r\n                                _a.label = 1;\r\n                            case 1:\r\n                                _a.trys.push([1, 3, , 4]);\r\n                                return [4 /*yield*/, this.askRoomLeave(leaveMsg)];\r\n                            case 2:\r\n                                _a.sent();\r\n                                return [3 /*break*/, 4];\r\n                            case 3:\r\n                                err_1 = _a.sent();\r\n                                return [2 /*return*/, err_1];\r\n                            case 4: return [2 /*return*/];\r\n                        }\r\n                    });\r\n                }); });\r\n                return [2 /*return*/, null];\r\n            });\r\n        });\r\n    };\r\n    NSConn.prototype.forceLeaveAll = function (isLocal) {\r\n        var _this = this;\r\n        var leaveMsg = new Message();\r\n        leaveMsg.Namespace = this.namespace;\r\n        leaveMsg.Event = OnRoomLeave;\r\n        leaveMsg.IsForced = true;\r\n        leaveMsg.IsLocal = isLocal;\r\n        this.rooms.forEach(function (value, roomName) {\r\n            leaveMsg.Room = roomName;\r\n            fireEvent(_this, leaveMsg);\r\n            _this.rooms.delete(roomName);\r\n            leaveMsg.Event = OnRoomLeft;\r\n            fireEvent(_this, leaveMsg);\r\n            leaveMsg.Event = OnRoomLeave;\r\n        });\r\n    };\r\n    /* The disconnect method sends a disconnect signal to the server and fires the `OnNamespaceDisconnect` event. */\r\n    NSConn.prototype.disconnect = function () {\r\n        var disconnectMsg = new Message();\r\n        disconnectMsg.Namespace = this.namespace;\r\n        disconnectMsg.Event = OnNamespaceDisconnect;\r\n        return this.conn.askDisconnect(disconnectMsg);\r\n    };\r\n    NSConn.prototype.askRoomJoin = function (roomName) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {\r\n            var room, joinMsg, err_2, err;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        room = this.rooms.get(roomName);\r\n                        if (room !== undefined) {\r\n                            resolve(room);\r\n                            return [2 /*return*/];\r\n                        }\r\n                        joinMsg = new Message();\r\n                        joinMsg.Namespace = this.namespace;\r\n                        joinMsg.Room = roomName;\r\n                        joinMsg.Event = OnRoomJoin;\r\n                        joinMsg.IsLocal = true;\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        _a.trys.push([1, 3, , 4]);\r\n                        return [4 /*yield*/, this.conn.ask(joinMsg)];\r\n                    case 2:\r\n                        _a.sent();\r\n                        return [3 /*break*/, 4];\r\n                    case 3:\r\n                        err_2 = _a.sent();\r\n                        reject(err_2);\r\n                        return [2 /*return*/];\r\n                    case 4:\r\n                        err = fireEvent(this, joinMsg);\r\n                        if (!isEmpty(err)) {\r\n                            reject(err);\r\n                            return [2 /*return*/];\r\n                        }\r\n                        room = new Room(this, roomName);\r\n                        this.rooms.set(roomName, room);\r\n                        joinMsg.Event = OnRoomJoined;\r\n                        fireEvent(this, joinMsg);\r\n                        resolve(room);\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        }); });\r\n    };\r\n    NSConn.prototype.askRoomLeave = function (msg) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var err_3, err;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        if (!this.rooms.has(msg.Room)) {\r\n                            return [2 /*return*/, ErrBadRoom];\r\n                        }\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        _a.trys.push([1, 3, , 4]);\r\n                        return [4 /*yield*/, this.conn.ask(msg)];\r\n                    case 2:\r\n                        _a.sent();\r\n                        return [3 /*break*/, 4];\r\n                    case 3:\r\n                        err_3 = _a.sent();\r\n                        return [2 /*return*/, err_3];\r\n                    case 4:\r\n                        err = fireEvent(this, msg);\r\n                        if (!isEmpty(err)) {\r\n                            return [2 /*return*/, err];\r\n                        }\r\n                        this.rooms.delete(msg.Room);\r\n                        msg.Event = OnRoomLeft;\r\n                        fireEvent(this, msg);\r\n                        return [2 /*return*/, null];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    NSConn.prototype.replyRoomJoin = function (msg) {\r\n        if (isEmpty(msg.wait) || msg.isNoOp) {\r\n            return;\r\n        }\r\n        if (!this.rooms.has(msg.Room)) {\r\n            var err = fireEvent(this, msg);\r\n            if (!isEmpty(err)) {\r\n                msg.Err = err;\r\n                this.conn.write(msg);\r\n                return;\r\n            }\r\n            this.rooms.set(msg.Room, new Room(this, msg.Room));\r\n            msg.Event = OnRoomJoined;\r\n            fireEvent(this, msg);\r\n        }\r\n        this.conn.writeEmptyReply(msg.wait);\r\n    };\r\n    NSConn.prototype.replyRoomLeave = function (msg) {\r\n        if (isEmpty(msg.wait) || msg.isNoOp) {\r\n            return;\r\n        }\r\n        if (!this.rooms.has(msg.Room)) {\r\n            this.conn.writeEmptyReply(msg.wait);\r\n            return;\r\n        }\r\n        fireEvent(this, msg);\r\n        this.rooms.delete(msg.Room);\r\n        this.conn.writeEmptyReply(msg.wait);\r\n        msg.Event = OnRoomLeft;\r\n        fireEvent(this, msg);\r\n    };\r\n    return NSConn;\r\n}());\r\nfunction fireEvent(ns, msg) {\r\n    if (ns.events.has(msg.Event)) {\r\n        return ns.events.get(msg.Event)(ns, msg);\r\n    }\r\n    if (ns.events.has(OnAnyEvent)) {\r\n        return ns.events.get(OnAnyEvent)(ns, msg);\r\n    }\r\n    return null;\r\n}\r\nfunction isNull(obj) {\r\n    return (obj === null || obj === undefined || typeof obj === 'undefined');\r\n}\r\nfunction resolveNamespaces(obj, reject) {\r\n    if (isNull(obj)) {\r\n        if (!isNull(reject)) {\r\n            reject(\"connHandler is empty.\");\r\n        }\r\n        return null;\r\n    }\r\n    var namespaces = new Map();\r\n    // 1. if contains function instead of a string key then it's Events otherwise it's Namespaces.\r\n    // 2. if contains a mix of functions and keys then ~put those functions to the namespaces[\"\"]~ it is NOT valid.\r\n    var events = new Map();\r\n    // const isMessageHandlerFunc = (value: any): value is MessageHandlerFunc => true;\r\n    var totalKeys = 0;\r\n    Object.keys(obj).forEach(function (key, index) {\r\n        totalKeys++;\r\n        var value = obj[key];\r\n        // if (isMessageHandlerFunc(value)) {\r\n        if (value instanceof Function) {\r\n            // console.log(key + \" event probably contains a message handler: \", value)\r\n            events.set(key, value);\r\n        }\r\n        else if (value instanceof Map) {\r\n            // console.log(key + \" is a namespace map which contains the following events: \", value)\r\n            namespaces.set(key, value);\r\n        }\r\n        else {\r\n            // it's an object, convert it to a map, it's events.\r\n            // console.log(key + \" is an object of: \", value);\r\n            var objEvents_1 = new Map();\r\n            Object.keys(value).forEach(function (objKey, objIndex) {\r\n                // console.log(\"set event: \" + objKey + \" of value: \", value[objKey])\r\n                objEvents_1.set(objKey, value[objKey]);\r\n            });\r\n            namespaces.set(key, objEvents_1);\r\n        }\r\n    });\r\n    if (events.size > 0) {\r\n        if (totalKeys != events.size) {\r\n            if (!isNull(reject)) {\r\n                reject(\"all keys of connHandler should be events, mix of namespaces and event callbacks is not supported \" + events.size + \" vs total \" + totalKeys);\r\n            }\r\n            return null;\r\n        }\r\n        namespaces.set(\"\", events);\r\n    }\r\n    // console.log(namespaces);\r\n    return namespaces;\r\n}\r\nfunction getEvents(namespaces, namespace) {\r\n    if (namespaces.has(namespace)) {\r\n        return namespaces.get(namespace);\r\n    }\r\n    return null;\r\n}\r\n/* This is the prefix that Options.header function is set to a url parameter's key in order to serve to parse it as header.\r\n The server's `URLParamAsHeaderPrefix` must match.\r\n Note that on the Nodejs side this is entirely optional, nodejs and go client support custom headers without url parameters parsing. */\r\nvar URLParamAsHeaderPrefix = \"X-Websocket-Header-\";\r\nfunction parseHeadersAsURLParameters(headers, url) {\r\n    if (isNull(headers)) {\r\n        return url;\r\n    }\r\n    for (var key in headers) {\r\n        if (headers.hasOwnProperty(key)) {\r\n            var value = headers[key];\r\n            key = encodeURIComponent(URLParamAsHeaderPrefix + key);\r\n            value = encodeURIComponent(value);\r\n            var part = key + \"=\" + value;\r\n            url = (url.indexOf(\"?\") != -1 ?\r\n                url.split(\"?\")[0] + \"?\" + part + \"&\" + url.split(\"?\")[1] :\r\n                (url.indexOf(\"#\") != -1 ? url.split(\"#\")[0] + \"?\" + part + \"#\" + url.split(\"#\")[1] : url + '?' + part));\r\n        }\r\n    }\r\n    return url;\r\n}\r\n/* The dial function returns a neffos client, a new `Conn` instance.\r\n   First parameter is the endpoint, i.e ws://localhost:8080/echo,\r\n   the second parameter can be any object of the form of:\r\n   namespace: {eventName: eventHandler, eventName2: ...} or {eventName: eventHandler}.\r\n   Example Code:\r\n    var conn = await neffos.dial(\"ws://localhost:8080/echo\", {\r\n      default: { // \"default\" namespace.\r\n        _OnNamespaceConnected: function (ns, msg) {\r\n          console.log(\"connected to namespace: \" + msg.Namespace);\r\n        },\r\n        _OnNamespaceDisconnect: function (ns, msg) {\r\n          console.log(\"disconnected from namespace: \" + msg.Namespace);\r\n        },\r\n        _OnRoomJoined: function (ns, msg) {\r\n          console.log(\"joined to room: \" + msg.Room);\r\n        },\r\n        _OnRoomLeft: function (ns, msg) {\r\n          console.log(\"left from room: \" + msg.Room);\r\n        },\r\n        chat: function (ns, msg) { // \"chat\" event.\r\n          let prefix = \"Server says: \";\r\n          if (msg.Room !== \"\") {\r\n            prefix = msg.Room + \" >> \";\r\n          }\r\n          console.log(prefix + msg.Body);\r\n        }\r\n      }\r\n    });\r\n\r\n    var nsConn = await conn.connect(\"default\");\r\n    nsConn.emit(\"chat\", \"Hello from client side!\");\r\n    See https://github.com/kataras/neffos.js/tree/master/_examples for more.\r\n*/\r\nfunction dial(endpoint, connHandler, options) {\r\n    return _dial(endpoint, connHandler, 0, options);\r\n}\r\n// this header key should match the server.ServeHTTP's.\r\nvar websocketReconnectHeaderKey = 'X-Websocket-Reconnect';\r\nfunction _dial(endpoint, connHandler, tries, options) {\r\n    if (isBrowser && endpoint.indexOf(\"/\") == 0) {\r\n        // if is running from browser and endpoint starts with /\r\n        // lets try to fix it, useful when developers changing environments and servers.\r\n        var scheme = document.location.protocol == \"https:\" ? \"wss\" : \"ws\";\r\n        var port = document.location.port ? \":\" + document.location.port : \"\";\r\n        endpoint = scheme + \"://\" + document.location.hostname + port + endpoint;\r\n    }\r\n    if (endpoint.indexOf(\"ws\") == -1) {\r\n        endpoint = \"ws://\" + endpoint;\r\n    }\r\n    return new Promise(function (resolve, reject) {\r\n        if (!WebSocket) {\r\n            reject(\"WebSocket is not accessible through this browser.\");\r\n        }\r\n        var namespaces = resolveNamespaces(connHandler, reject);\r\n        if (isNull(namespaces)) {\r\n            return;\r\n        }\r\n        if (isNull(options)) {\r\n            options = {};\r\n        }\r\n        if (isNull(options.headers)) {\r\n            options.headers = {};\r\n        }\r\n        var reconnectEvery = (options.reconnect) ? options.reconnect : 0;\r\n        if (tries > 0 && reconnectEvery > 0) {\r\n            //     options.headers = {\r\n            //         [websocketReconnectHeaderKey]: tries.toString()\r\n            //     };\r\n            options.headers[websocketReconnectHeaderKey] = tries.toString();\r\n        }\r\n        else if (!isNull(options.headers[websocketReconnectHeaderKey])) /* against tricks */ {\r\n            delete options.headers[websocketReconnectHeaderKey];\r\n        }\r\n        var ws = makeWebsocketConnection(endpoint, options);\r\n        var conn = new Conn(ws, namespaces);\r\n        conn.reconnectTries = tries;\r\n        ws.binaryType = \"arraybuffer\";\r\n        ws.onmessage = (function (evt) {\r\n            var err = conn.handle(evt);\r\n            if (!isEmpty(err)) {\r\n                reject(err);\r\n                return;\r\n            }\r\n            if (conn.isAcknowledged()) {\r\n                resolve(conn);\r\n            }\r\n        });\r\n        ws.onopen = (function (evt) {\r\n            // let b = new Uint8Array(1)\r\n            // b[0] = 1;\r\n            // this.conn.send(b.buffer);\r\n            ws.send(ackBinary);\r\n        });\r\n        ws.onerror = (function (err) {\r\n            // if (err.type !== undefined && err.type == \"error\" && (ws.readyState == ws.CLOSED || ws.readyState == ws.CLOSING)) {\r\n            //     // for any case, it should never happen.\r\n            //     return;\r\n            // }\r\n            conn.close();\r\n            reject(err);\r\n        });\r\n        ws.onclose = (function (evt) {\r\n            if (conn.isClosed()) {\r\n                // reconnection is NOT allowed when:\r\n                // 1. server force-disconnect this client.\r\n                // 2. client disconnects itself manually.\r\n                // We check those two ^ with conn.isClosed().\r\n                // console.log(\"manual disconnect.\")\r\n            }\r\n            else {\r\n                // disable all previous event callbacks.\r\n                ws.onmessage = undefined;\r\n                ws.onopen = undefined;\r\n                ws.onerror = undefined;\r\n                ws.onclose = undefined;\r\n                if (reconnectEvery <= 0) {\r\n                    conn.close();\r\n                    return null;\r\n                }\r\n                // get the connected namespaces before .close clears.\r\n                var previouslyConnectedNamespacesNamesOnly_1 = new Map(); // connected namespaces[key] -> [values]joined rooms;\r\n                conn.connectedNamespaces.forEach(function (nsConn, name) {\r\n                    var previouslyJoinedRooms = new Array();\r\n                    if (!isNull(nsConn.rooms) && nsConn.rooms.size > 0) {\r\n                        nsConn.rooms.forEach(function (roomConn, roomName) {\r\n                            previouslyJoinedRooms.push(roomName);\r\n                        });\r\n                    }\r\n                    previouslyConnectedNamespacesNamesOnly_1.set(name, previouslyJoinedRooms);\r\n                });\r\n                conn.close();\r\n                whenResourceOnline(endpoint, reconnectEvery, function (tries) {\r\n                    _dial(endpoint, connHandler, tries, options).then(function (newConn) {\r\n                        if (isNull(resolve) || resolve.toString() == \"function () { [native code] }\") {\r\n                            // Idea behind the below:\r\n                            // If the original promise was in try-catch statement instead of .then and .catch callbacks\r\n                            // then this block will be called however, we don't have a way\r\n                            // to guess the user's actions in a try block, so we at least,\r\n                            //  we will try to reconnect to the previous namespaces automatically here.\r\n                            previouslyConnectedNamespacesNamesOnly_1.forEach(function (joinedRooms, name) {\r\n                                var whenConnected = function (joinedRooms) {\r\n                                    return function (newNSConn) {\r\n                                        joinedRooms.forEach(function (roomName) {\r\n                                            newNSConn.joinRoom(roomName);\r\n                                        });\r\n                                    };\r\n                                };\r\n                                newConn.connect(name).then(whenConnected(joinedRooms));\r\n                            });\r\n                            return;\r\n                        }\r\n                        resolve(newConn);\r\n                    }).catch(reject);\r\n                });\r\n            }\r\n            return null;\r\n        });\r\n    });\r\n}\r\nfunction makeWebsocketConnection(endpoint, options) {\r\n    if (isBrowser) {\r\n        if (!isNull(options)) {\r\n            if (options.headers) {\r\n                endpoint = parseHeadersAsURLParameters(options.headers, endpoint);\r\n            }\r\n            if (options.protocols) {\r\n                return new WebSocket(endpoint, options.protocols);\r\n            }\r\n            else {\r\n                return new WebSocket(endpoint);\r\n            }\r\n        }\r\n    }\r\n    return new WebSocket(endpoint, options);\r\n}\r\nfunction whenResourceOnline(endpoint, checkEvery, notifyOnline) {\r\n    // Don't fire webscoket requests just yet.\r\n    // We check if the HTTP endpoint is alive with a simple fetch, if it is alive then we notify the caller\r\n    // to proceed with a websocket request. That way we can notify the server-side how many times\r\n    // this client was trying to reconnect as well.\r\n    // Note:\r\n    // Chrome itself is emitting net::ERR_CONNECTION_REFUSED and the final Bad Request messages to the console on network failures on fetch,\r\n    // there is no way to block them programmatically, we could do a console.clear but this will clear any custom logging the end-dev may has too.\r\n    var endpointHTTP = endpoint.replace(/(ws)(s)?\\:\\/\\//, \"http$2://\");\r\n    // counts and sends as header the previous failures (if any) and the succeed last one.\r\n    var tries = 1;\r\n    var fetchOptions = { method: 'HEAD', mode: 'no-cors' };\r\n    var check = function () {\r\n        // Note:\r\n        // We do not fire a try immediately after the disconnection as most developers will expect.\r\n        _fetch(endpointHTTP, fetchOptions).then(function () {\r\n            notifyOnline(tries);\r\n        }).catch(function () {\r\n            // if (err !== undefined && err.toString() !== \"TypeError: Failed to fetch\") {\r\n            //     console.log(err);\r\n            // }\r\n            tries++;\r\n            setTimeout(function () {\r\n                check();\r\n            }, checkEvery);\r\n        });\r\n    };\r\n    setTimeout(check, checkEvery);\r\n}\r\nvar ErrInvalidPayload = new Error(\"invalid payload\");\r\nvar ErrBadNamespace = new Error(\"bad namespace\");\r\nvar ErrBadRoom = new Error(\"bad room\");\r\nvar ErrClosed = new Error(\"use of closed connection\");\r\nvar ErrWrite = new Error(\"write closed\");\r\n/* The isCloseError function reports whether incoming error is received because of server shutdown. */\r\nfunction isCloseError(err) {\r\n    if (err && !isEmpty(err.message)) {\r\n        return err.message.indexOf(\"[-1] write closed\") >= 0;\r\n    }\r\n    return false;\r\n}\r\n/* The Conn class contains the websocket connection and the neffos communication functionality.\r\n   Its `connect` will return a new `NSConn` instance, each connection can connect to one or more namespaces.\r\n   Each `NSConn` can join to multiple rooms. */\r\nvar Conn = /** @class */ (function () {\r\n    // private isConnectingProcesseses: string[]; // if elem exists then any receive of that namespace is locked until `askConnect` finished.\r\n    function Conn(conn, namespaces) {\r\n        this.conn = conn;\r\n        this.reconnectTries = 0;\r\n        this._isAcknowledged = false;\r\n        this.namespaces = namespaces;\r\n        var hasEmptyNS = namespaces.has(\"\");\r\n        this.allowNativeMessages = hasEmptyNS && namespaces.get(\"\").has(OnNativeMessage);\r\n        this.queue = new Array();\r\n        this.waitingMessages = new Map();\r\n        this.connectedNamespaces = new Map();\r\n        // this.isConnectingProcesseses = new Array<string>();\r\n        this.closed = false;\r\n        // this.conn.onclose = ((evt: Event): any => {\r\n        //     this.close();\r\n        //     return null;\r\n        // });\r\n    }\r\n    /* The wasReconnected method reports whether the current connection is the result of a reconnection.\r\n       To get the numbers of total retries see the `reconnectTries` field. */\r\n    Conn.prototype.wasReconnected = function () {\r\n        return this.reconnectTries > 0;\r\n    };\r\n    Conn.prototype.isAcknowledged = function () {\r\n        return this._isAcknowledged;\r\n    };\r\n    Conn.prototype.handle = function (evt) {\r\n        if (!this._isAcknowledged) {\r\n            // if (evt.data instanceof ArrayBuffer) {\r\n            // new Uint8Array(evt.data)\r\n            var err = this.handleAck(evt.data);\r\n            if (err == undefined) {\r\n                this._isAcknowledged = true;\r\n                this.handleQueue();\r\n            }\r\n            else {\r\n                this.conn.close();\r\n            }\r\n            return err;\r\n        }\r\n        return this.handleMessage(evt.data);\r\n    };\r\n    Conn.prototype.handleAck = function (data) {\r\n        var typ = data[0];\r\n        switch (typ) {\r\n            case ackIDBinary:\r\n                // let id = dec.decode(data.slice(1));\r\n                var id = data.slice(1);\r\n                this.ID = id;\r\n                break;\r\n            case ackNotOKBinary:\r\n                // let errorText = dec.decode(data.slice(1));\r\n                var errorText = data.slice(1);\r\n                return new Error(errorText);\r\n            default:\r\n                this.queue.push(data);\r\n                return null;\r\n        }\r\n    };\r\n    Conn.prototype.handleQueue = function () {\r\n        var _this = this;\r\n        if (this.queue == undefined || this.queue.length == 0) {\r\n            return;\r\n        }\r\n        this.queue.forEach(function (item, index) {\r\n            _this.queue.splice(index, 1);\r\n            _this.handleMessage(item);\r\n        });\r\n    };\r\n    Conn.prototype.handleMessage = function (data) {\r\n        var msg = deserializeMessage(data, this.allowNativeMessages);\r\n        if (msg.isInvalid) {\r\n            return ErrInvalidPayload;\r\n        }\r\n        if (msg.IsNative && this.allowNativeMessages) {\r\n            var ns_1 = this.namespace(\"\");\r\n            return fireEvent(ns_1, msg);\r\n        }\r\n        if (msg.isWait()) {\r\n            var cb = this.waitingMessages.get(msg.wait);\r\n            if (cb != undefined) {\r\n                cb(msg);\r\n                return;\r\n            }\r\n        }\r\n        var ns = this.namespace(msg.Namespace);\r\n        switch (msg.Event) {\r\n            case OnNamespaceConnect:\r\n                this.replyConnect(msg);\r\n                break;\r\n            case OnNamespaceDisconnect:\r\n                this.replyDisconnect(msg);\r\n                break;\r\n            case OnRoomJoin:\r\n                if (ns !== undefined) {\r\n                    ns.replyRoomJoin(msg);\r\n                    break;\r\n                }\r\n            case OnRoomLeave:\r\n                if (ns !== undefined) {\r\n                    ns.replyRoomLeave(msg);\r\n                    break;\r\n                }\r\n            default:\r\n                // this.checkWaitForNamespace(msg.Namespace);\r\n                if (ns === undefined) {\r\n                    return ErrBadNamespace;\r\n                }\r\n                msg.IsLocal = false;\r\n                var err = fireEvent(ns, msg);\r\n                if (!isEmpty(err)) {\r\n                    // write any error back to the server.\r\n                    msg.Err = err;\r\n                    this.write(msg);\r\n                    return err;\r\n                }\r\n        }\r\n        return null;\r\n    };\r\n    /* The connect method returns a new connected to the specific \"namespace\" `NSConn` instance or an error. */\r\n    Conn.prototype.connect = function (namespace) {\r\n        return this.askConnect(namespace);\r\n    };\r\n    /* waitServerConnect method blocks until server manually calls the connection's `Connect`\r\n       on the `Server#OnConnected` event. */\r\n    Conn.prototype.waitServerConnect = function (namespace) {\r\n        var _this = this;\r\n        if (isNull(this.waitServerConnectNotifiers)) {\r\n            this.waitServerConnectNotifiers = new Map();\r\n        }\r\n        return new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                this.waitServerConnectNotifiers.set(namespace, function () {\r\n                    _this.waitServerConnectNotifiers.delete(namespace);\r\n                    resolve(_this.namespace(namespace));\r\n                });\r\n                return [2 /*return*/];\r\n            });\r\n        }); });\r\n    };\r\n    /* The namespace method returns an already connected `NSConn`. */\r\n    Conn.prototype.namespace = function (namespace) {\r\n        return this.connectedNamespaces.get(namespace);\r\n    };\r\n    Conn.prototype.replyConnect = function (msg) {\r\n        if (isEmpty(msg.wait) || msg.isNoOp) {\r\n            return;\r\n        }\r\n        var ns = this.namespace(msg.Namespace);\r\n        if (ns !== undefined) {\r\n            this.writeEmptyReply(msg.wait);\r\n            return;\r\n        }\r\n        var events = getEvents(this.namespaces, msg.Namespace);\r\n        if (isNull(events)) {\r\n            msg.Err = ErrBadNamespace;\r\n            this.write(msg);\r\n            return;\r\n        }\r\n        ns = new NSConn(this, msg.Namespace, events);\r\n        this.connectedNamespaces.set(msg.Namespace, ns);\r\n        this.writeEmptyReply(msg.wait);\r\n        msg.Event = OnNamespaceConnected;\r\n        fireEvent(ns, msg);\r\n        if (!isNull(this.waitServerConnectNotifiers) && this.waitServerConnectNotifiers.size > 0) {\r\n            if (this.waitServerConnectNotifiers.has(msg.Namespace)) {\r\n                this.waitServerConnectNotifiers.get(msg.Namespace)();\r\n            }\r\n        }\r\n    };\r\n    Conn.prototype.replyDisconnect = function (msg) {\r\n        if (isEmpty(msg.wait) || msg.isNoOp) {\r\n            return;\r\n        }\r\n        var ns = this.namespace(msg.Namespace);\r\n        if (ns === undefined) {\r\n            this.writeEmptyReply(msg.wait);\r\n            return;\r\n        }\r\n        ns.forceLeaveAll(true);\r\n        this.connectedNamespaces.delete(msg.Namespace);\r\n        this.writeEmptyReply(msg.wait);\r\n        fireEvent(ns, msg);\r\n    };\r\n    /* The ask method writes a message to the server and blocks until a response or an error received. */\r\n    Conn.prototype.ask = function (msg) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) {\r\n            if (_this.isClosed()) {\r\n                reject(ErrClosed);\r\n                return;\r\n            }\r\n            msg.wait = genWait();\r\n            _this.waitingMessages.set(msg.wait, (function (receive) {\r\n                if (receive.isError) {\r\n                    reject(receive.Err);\r\n                    return;\r\n                }\r\n                resolve(receive);\r\n            }));\r\n            if (!_this.write(msg)) {\r\n                reject(ErrWrite);\r\n                return;\r\n            }\r\n        });\r\n    };\r\n    // private addConnectProcess(namespace: string) {\r\n    //     this.isConnectingProcesseses.push(namespace);\r\n    // }\r\n    // private removeConnectProcess(namespace: string) {\r\n    //     let idx = this.isConnectingProcesseses.findIndex((value: string, index: number, obj) => { return value === namespace || false; });\r\n    //     if (idx !== -1) {\r\n    //         this.isConnectingProcesseses.splice(idx, 1);\r\n    //     }\r\n    // }\r\n    Conn.prototype.askConnect = function (namespace) {\r\n        var _this = this;\r\n        return new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {\r\n            var ns, events, connectMessage, err, err_4;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        ns = this.namespace(namespace);\r\n                        if (ns !== undefined) { // it's already connected.\r\n                            resolve(ns);\r\n                            return [2 /*return*/];\r\n                        }\r\n                        events = getEvents(this.namespaces, namespace);\r\n                        if (isNull(events)) {\r\n                            reject(ErrBadNamespace);\r\n                            return [2 /*return*/];\r\n                        }\r\n                        connectMessage = new Message();\r\n                        connectMessage.Namespace = namespace;\r\n                        connectMessage.Event = OnNamespaceConnect;\r\n                        connectMessage.IsLocal = true;\r\n                        ns = new NSConn(this, namespace, events);\r\n                        err = fireEvent(ns, connectMessage);\r\n                        if (!isEmpty(err)) {\r\n                            // this.removeConnectProcess(namespace);\r\n                            reject(err);\r\n                            return [2 /*return*/];\r\n                        }\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        _a.trys.push([1, 3, , 4]);\r\n                        return [4 /*yield*/, this.ask(connectMessage)];\r\n                    case 2:\r\n                        _a.sent();\r\n                        return [3 /*break*/, 4];\r\n                    case 3:\r\n                        err_4 = _a.sent();\r\n                        reject(err_4);\r\n                        return [2 /*return*/];\r\n                    case 4:\r\n                        this.connectedNamespaces.set(namespace, ns);\r\n                        connectMessage.Event = OnNamespaceConnected;\r\n                        fireEvent(ns, connectMessage);\r\n                        resolve(ns);\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        }); });\r\n    };\r\n    Conn.prototype.askDisconnect = function (msg) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var ns, err_5;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        ns = this.namespace(msg.Namespace);\r\n                        if (ns === undefined) { // it's already connected.\r\n                            return [2 /*return*/, ErrBadNamespace];\r\n                        }\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        _a.trys.push([1, 3, , 4]);\r\n                        return [4 /*yield*/, this.ask(msg)];\r\n                    case 2:\r\n                        _a.sent();\r\n                        return [3 /*break*/, 4];\r\n                    case 3:\r\n                        err_5 = _a.sent();\r\n                        return [2 /*return*/, err_5];\r\n                    case 4:\r\n                        ns.forceLeaveAll(true);\r\n                        this.connectedNamespaces.delete(msg.Namespace);\r\n                        msg.IsLocal = true;\r\n                        return [2 /*return*/, fireEvent(ns, msg)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /* The isClosed method reports whether this connection is closed. */\r\n    Conn.prototype.isClosed = function () {\r\n        return this.closed; // || this.conn.readyState == this.conn.CLOSED || false;\r\n    };\r\n    /* The write method writes a message to the server and reports whether the connection is still available. */\r\n    Conn.prototype.write = function (msg) {\r\n        if (this.isClosed()) {\r\n            return false;\r\n        }\r\n        if (!msg.isConnect() && !msg.isDisconnect()) {\r\n            // namespace pre-write check.\r\n            var ns = this.namespace(msg.Namespace);\r\n            if (ns === undefined) {\r\n                return false;\r\n            }\r\n            // room per-write check.\r\n            if (!isEmpty(msg.Room) && !msg.isRoomJoin() && !msg.isRoomLeft()) {\r\n                if (!ns.rooms.has(msg.Room)) {\r\n                    // tried to send to a not joined room.\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        // if (msg.SetBinary) {\r\n        //     if (!(\"TextEncoder\" in window)) {\r\n        //         throw new Error(\"this browser does not support Text Encoding/Decoding...\");\r\n        //     }\r\n        //     (msg.Body as unknown) = new TextEncoder().encode(msg.Body);\r\n        // }\r\n        // this.conn.send(serializeMessage(msg));\r\n        //\r\n        // var data:string|Uint8Array = serializeMessage(msg)\r\n        // if (msg.SetBinary) {\r\n        //     if (!(\"TextEncoder\" in window)) {\r\n        //         throw new Error(\"this browser does not support Text Encoding/Decoding...\");\r\n        //     }\r\n        //     data = new TextEncoder().encode(data);\r\n        // }\r\n        // this.conn.send(data);\r\n        this.conn.send(serializeMessage(msg));\r\n        return true;\r\n    };\r\n    Conn.prototype.writeEmptyReply = function (wait) {\r\n        this.conn.send(genEmptyReplyToWait(wait));\r\n    };\r\n    /* The close method will force-disconnect from all connected namespaces and force-leave from all joined rooms\r\n       and finally will terminate the underline websocket connection. After this method call the `Conn` is not usable anymore, a new `dial` call is required. */\r\n    Conn.prototype.close = function () {\r\n        var _this = this;\r\n        if (this.closed) {\r\n            return;\r\n        }\r\n        var disconnectMsg = new Message();\r\n        disconnectMsg.Event = OnNamespaceDisconnect;\r\n        disconnectMsg.IsForced = true;\r\n        disconnectMsg.IsLocal = true;\r\n        this.connectedNamespaces.forEach(function (ns) {\r\n            ns.forceLeaveAll(true);\r\n            disconnectMsg.Namespace = ns.namespace;\r\n            fireEvent(ns, disconnectMsg);\r\n            _this.connectedNamespaces.delete(ns.namespace);\r\n        });\r\n        this.waitingMessages.clear();\r\n        this.closed = true;\r\n        if (this.conn.readyState === this.conn.OPEN) {\r\n            this.conn.close();\r\n        }\r\n    };\r\n    return Conn;\r\n}());\r\n(function () {\r\n    // interface Neffos {\r\n    //     dial(...)\r\n    // }\r\n    // const neffos: Neffos = {\r\n    //    dial:dial,\r\n    // }\r\n    var neffos = {\r\n        // main functions.\r\n        dial: dial,\r\n        isSystemEvent: isSystemEvent,\r\n        // constants (events).\r\n        OnNamespaceConnect: OnNamespaceConnect,\r\n        OnNamespaceConnected: OnNamespaceConnected,\r\n        OnNamespaceDisconnect: OnNamespaceDisconnect,\r\n        OnRoomJoin: OnRoomJoin,\r\n        OnRoomJoined: OnRoomJoined,\r\n        OnRoomLeave: OnRoomLeave,\r\n        OnRoomLeft: OnRoomLeft,\r\n        OnAnyEvent: OnAnyEvent,\r\n        OnNativeMessage: OnNativeMessage,\r\n        // classes.\r\n        Message: Message,\r\n        Room: Room,\r\n        NSConn: NSConn,\r\n        Conn: Conn,\r\n        // errors.\r\n        ErrInvalidPayload: ErrInvalidPayload,\r\n        ErrBadNamespace: ErrBadNamespace,\r\n        ErrBadRoom: ErrBadRoom,\r\n        ErrClosed: ErrClosed,\r\n        ErrWrite: ErrWrite,\r\n        isCloseError: isCloseError,\r\n        reply: reply,\r\n        marshal: marshal\r\n    };\r\n    if (true) {\r\n        exports = neffos;\r\n        module.exports = neffos;\r\n    }\r\n    else { var root; }\r\n}());\r\n//# sourceMappingURL=neffos.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/neffos.js/dist/neffos.js?");

/***/ }),

/***/ "./node_modules/neffos.js/node_modules/ws/browser.js":
/*!***********************************************************!*\
  !*** ./node_modules/neffos.js/node_modules/ws/browser.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function() {\n  throw new Error(\n    'ws does not work in the browser. Browser clients must use the native ' +\n      'WebSocket object'\n  );\n};\n\n\n//# sourceURL=webpack:///./node_modules/neffos.js/node_modules/ws/browser.js?");

/***/ }),

/***/ "./node_modules/node-fetch/browser.js":
/*!********************************************!*\
  !*** ./node_modules/node-fetch/browser.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// ref: https://github.com/tc39/proposal-global\nvar getGlobal = function () {\n\t// the only reliable means to get the global object is\n\t// `Function('return this')()`\n\t// However, this causes CSP violations in Chrome apps.\n\tif (typeof self !== 'undefined') { return self; }\n\tif (typeof window !== 'undefined') { return window; }\n\tif (typeof global !== 'undefined') { return global; }\n\tthrow new Error('unable to locate global object');\n}\n\nvar global = getGlobal();\n\nmodule.exports = exports = global.fetch;\n\n// Needed for TypeScript and Webpack.\nexports.default = global.fetch.bind(global);\n\nexports.Headers = global.Headers;\nexports.Request = global.Request;\nexports.Response = global.Response;\n\n//# sourceURL=webpack:///./node_modules/node-fetch/browser.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar stylesInDom = {};\n\nvar isOldIE = function isOldIE() {\n  var memo;\n  return function memorize() {\n    if (typeof memo === 'undefined') {\n      // Test for IE <= 9 as proposed by Browserhacks\n      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n      // Tests for existence of standard globals is to allow style-loader\n      // to operate correctly into non-standard environments\n      // @see https://github.com/webpack-contrib/style-loader/issues/177\n      memo = Boolean(window && document && document.all && !window.atob);\n    }\n\n    return memo;\n  };\n}();\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nfunction listToStyles(list, options) {\n  var styles = [];\n  var newStyles = {};\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var css = item[1];\n    var media = item[2];\n    var sourceMap = item[3];\n    var part = {\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    };\n\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = {\n        id: id,\n        parts: [part]\n      });\n    } else {\n      newStyles[id].parts.push(part);\n    }\n  }\n\n  return styles;\n}\n\nfunction addStylesToDom(styles, options) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i];\n    var domStyle = stylesInDom[item.id];\n    var j = 0;\n\n    if (domStyle) {\n      domStyle.refs++;\n\n      for (; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j]);\n      }\n\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j], options));\n      }\n    } else {\n      var parts = [];\n\n      for (; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j], options));\n      }\n\n      stylesInDom[item.id] = {\n        id: item.id,\n        refs: 1,\n        parts: parts\n      };\n    }\n  }\n}\n\nfunction insertStyleElement(options) {\n  var style = document.createElement('style');\n\n  if (typeof options.attributes.nonce === 'undefined') {\n    var nonce =  true ? __webpack_require__.nc : undefined;\n\n    if (nonce) {\n      options.attributes.nonce = nonce;\n    }\n  }\n\n  Object.keys(options.attributes).forEach(function (key) {\n    style.setAttribute(key, options.attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(style);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(style);\n  }\n\n  return style;\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join('\\n');\n  };\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n  var css = remove ? '' : obj.css; // For old IE\n\n  /* istanbul ignore if  */\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = style.childNodes;\n\n    if (childNodes[index]) {\n      style.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      style.insertBefore(cssNode, childNodes[index]);\n    } else {\n      style.appendChild(cssNode);\n    }\n  }\n}\n\nfunction applyToTag(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute('media', media);\n  }\n\n  if (sourceMap && btoa) {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar singleton = null;\nvar singletonCounter = 0;\n\nfunction addStyle(obj, options) {\n  var style;\n  var update;\n  var remove;\n\n  if (options.singleton) {\n    var styleIndex = singletonCounter++;\n    style = singleton || (singleton = insertStyleElement(options));\n    update = applyToSingletonTag.bind(null, style, styleIndex, false);\n    remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n  } else {\n    style = insertStyleElement(options);\n    update = applyToTag.bind(null, style, options);\n\n    remove = function remove() {\n      removeStyleElement(style);\n    };\n  }\n\n  update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      update(obj = newObj);\n    } else {\n      remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {};\n  options.attributes = typeof options.attributes === 'object' ? options.attributes : {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n  // tags it will allow on a page\n\n  if (!options.singleton && typeof options.singleton !== 'boolean') {\n    options.singleton = isOldIE();\n  }\n\n  var styles = listToStyles(list, options);\n  addStylesToDom(styles, options);\n  return function update(newList) {\n    var mayRemove = [];\n\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i];\n      var domStyle = stylesInDom[item.id];\n\n      if (domStyle) {\n        domStyle.refs--;\n        mayRemove.push(domStyle);\n      }\n    }\n\n    if (newList) {\n      var newStyles = listToStyles(newList, options);\n      addStylesToDom(newStyles, options);\n    }\n\n    for (var _i = 0; _i < mayRemove.length; _i++) {\n      var _domStyle = mayRemove[_i];\n\n      if (_domStyle.refs === 0) {\n        for (var j = 0; j < _domStyle.parts.length; j++) {\n          _domStyle.parts[j]();\n        }\n\n        delete stylesInDom[_domStyle.id];\n      }\n    }\n  };\n};\n\n//# sourceURL=webpack:///./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./src/css/main.less":
/*!***************************!*\
  !*** ./src/css/main.less ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var content = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js!../../node_modules/less-loader/dist/cjs.js??ref--5-2!./main.less */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js?!./src/css/main.less\");\n\nif (typeof content === 'string') {\n  content = [[module.i, content, '']];\n}\n\nvar options = {}\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = __webpack_require__(/*! ../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\")(content, options);\n\nif (content.locals) {\n  module.exports = content.locals;\n}\n\n\n//# sourceURL=webpack:///./src/css/main.less?");

/***/ }),

/***/ "./src/js/app.ts":
/*!***********************!*\
  !*** ./src/js/app.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Game_1 = __webpack_require__(/*! ./core/Game */ \"./src/js/core/Game.ts\");\r\n__webpack_require__(/*! ../css/main.less */ \"./src/css/main.less\");\r\nclass App {\r\n    constructor() {\r\n        this.init();\r\n        Game_1.Game.start(\"1000\", \"600\");\r\n    }\r\n    init() {\r\n        const wrapperSelector = document.querySelector(\".wrapper\");\r\n        const menuSelector = document.querySelector(\"#menu\");\r\n        const playSelector = document.querySelector(\".play\");\r\n        wrapperSelector.style.height = \"600\" + \"px\";\r\n        wrapperSelector.style.width = \"1000\" + \"px\";\r\n        playSelector.addEventListener(\"click\", () => {\r\n            menuSelector.style.display = \"none\";\r\n        });\r\n    }\r\n}\r\nwindow.onload = () => {\r\n    new App();\r\n};\r\n\n\n//# sourceURL=webpack:///./src/js/app.ts?");

/***/ }),

/***/ "./src/js/components/Ball.ts":
/*!***********************************!*\
  !*** ./src/js/components/Ball.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Game_1 = __webpack_require__(/*! ../core/Game */ \"./src/js/core/Game.ts\");\r\nconst Component_1 = __webpack_require__(/*! ./Component */ \"./src/js/components/Component.ts\");\r\nclass Ball extends Component_1.Component {\r\n    constructor(position) {\r\n        super();\r\n        if (position) {\r\n            this.position.copy(position);\r\n        }\r\n    }\r\n    render() {\r\n        Game_1.Game.graphics.circle(this.x, this.y, 10, 0, Math.PI * 2, true);\r\n    }\r\n}\r\nexports.Ball = Ball;\r\n\n\n//# sourceURL=webpack:///./src/js/components/Ball.ts?");

/***/ }),

/***/ "./src/js/components/Component.ts":
/*!****************************************!*\
  !*** ./src/js/components/Component.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Vector_1 = __webpack_require__(/*! ../util/Vector */ \"./src/js/util/Vector.ts\");\r\nclass Component {\r\n    constructor() {\r\n        this.position = new Vector_1.Vector(0, 0);\r\n    }\r\n    // public size: Vector = new Vector(0, 0);\r\n    get x() { return this.position.x; }\r\n    set x(val) { this.position.x = val; }\r\n    get y() { return this.position.y; }\r\n    set y(val) { this.position.y = val; }\r\n}\r\nexports.Component = Component;\r\n\n\n//# sourceURL=webpack:///./src/js/components/Component.ts?");

/***/ }),

/***/ "./src/js/components/Paddle.ts":
/*!*************************************!*\
  !*** ./src/js/components/Paddle.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Game_1 = __webpack_require__(/*! ../core/Game */ \"./src/js/core/Game.ts\");\r\nconst Vector_1 = __webpack_require__(/*! ../util/Vector */ \"./src/js/util/Vector.ts\");\r\nconst Component_1 = __webpack_require__(/*! ./Component */ \"./src/js/components/Component.ts\");\r\nclass Paddle extends Component_1.Component {\r\n    constructor(size, position) {\r\n        super();\r\n        this.size = new Vector_1.Vector(0, 0);\r\n        this.size.copy(size);\r\n        if (position) {\r\n            this.position.copy(position);\r\n        }\r\n    }\r\n    get width() { return this.size.x; }\r\n    set width(val) { this.size.x = val; }\r\n    get height() { return this.size.y; }\r\n    set height(val) { this.size.y = val; }\r\n    render() {\r\n        Game_1.Game.graphics.rect(this.x, this.y, this.width, this.height, \"white\");\r\n    }\r\n}\r\nexports.Paddle = Paddle;\r\n\n\n//# sourceURL=webpack:///./src/js/components/Paddle.ts?");

/***/ }),

/***/ "./src/js/core/Game.ts":
/*!*****************************!*\
  !*** ./src/js/core/Game.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Ball_1 = __webpack_require__(/*! ../components/Ball */ \"./src/js/components/Ball.ts\");\r\nconst Paddle_1 = __webpack_require__(/*! ../components/Paddle */ \"./src/js/components/Paddle.ts\");\r\nconst Networking_1 = __webpack_require__(/*! ../core/Networking */ \"./src/js/core/Networking.ts\");\r\nconst Mouse_1 = __webpack_require__(/*! ../input/Mouse */ \"./src/js/input/Mouse.ts\");\r\nconst Vector_1 = __webpack_require__(/*! ../util/Vector */ \"./src/js/util/Vector.ts\");\r\nconst Graphics_1 = __webpack_require__(/*! ./Graphics */ \"./src/js/core/Graphics.ts\");\r\nclass Game {\r\n    constructor() {\r\n        this.root = null;\r\n        this.paddleGap = 15;\r\n        if (Game.instance != null) {\r\n            throw Error(\"Game has already been instantiated\");\r\n        }\r\n        if (!Game.start) {\r\n            throw Error(\"Game must be instantiated through static Game.start\");\r\n        }\r\n        Game.instance = this;\r\n        this.startTime = Date.now();\r\n    }\r\n    static start(width, height) {\r\n        Game.started = true;\r\n        new Game();\r\n        Game.instance.paddleHeight = Math.round(height / 4);\r\n        Game.instance.paddleWidth = Math.round(Game.instance.paddleHeight / 15);\r\n        // init\r\n        Game.instance.root = document.body || document.getElementsByTagName(\"body\")[0];\r\n        Game.instance.graphics = new Graphics_1.Graphics();\r\n        Game.resize(width, height);\r\n        Game.instance.ball = new Ball_1.Ball(new Vector_1.Vector(this.width / 2, this.height / 2));\r\n        Game.instance.paddle = new Paddle_1.Paddle(new Vector_1.Vector(Game.instance.paddleWidth, Game.instance.paddleHeight), new Vector_1.Vector(Game.instance.paddleGap, this.height / 2 - Game.instance.paddleHeight / 2));\r\n        Game.instance.paddle2 = new Paddle_1.Paddle(new Vector_1.Vector(Game.instance.paddleWidth, Game.instance.paddleHeight), new Vector_1.Vector(Game.instance.width - Game.instance.paddleGap - Game.instance.paddleWidth, this.height / 2 - Game.instance.paddleHeight / 2));\r\n        Mouse_1.Mouse.init();\r\n        // networking\r\n        Networking_1.Networking.init();\r\n        // (async () => {Game.instance.nsConn = await Networking.connect(); } )();\r\n        Networking_1.Networking.connect().then((conn) => {\r\n            Game.instance.nsConn = conn;\r\n            // start update loop\r\n            Game.instance.step();\r\n        });\r\n    }\r\n    static resize(width, height) {\r\n        Game.instance.width = width;\r\n        Game.instance.height = height;\r\n        Game.instance.graphics.resize();\r\n    }\r\n    static get width() { return Game.instance.width; }\r\n    static get height() { return Game.instance.height; }\r\n    static get root() { return Game.instance.root; }\r\n    static get graphics() { return Game.instance.graphics; }\r\n    static get paddleHeight() { return Game.instance.paddleHeight; }\r\n    static get paddleWidth() { return Game.instance.paddleWidth; }\r\n    static get paddle() { return Game.instance.paddle; }\r\n    static get paddle2() { return Game.instance.paddle2; }\r\n    static get conn() { return Game.instance.nsConn; }\r\n    static set conn(val) { Game.instance.nsConn = val; }\r\n    step() {\r\n        // time management!\r\n        const time = Date.now();\r\n        this.elapsed = Math.floor(time - this.startTime) / 1000;\r\n        this.dt = Math.floor(time - this.lastTime) / 1000;\r\n        this.lastTime = time;\r\n        // update inputs\r\n        Mouse_1.Mouse.update();\r\n        // update positions\r\n        if (Mouse_1.Mouse.startedMoving) {\r\n            Game.instance.nsConn.emit(\"input\", JSON.stringify(Mouse_1.Mouse.pos));\r\n        }\r\n        // render\r\n        this.graphics.clear();\r\n        this.ball.render();\r\n        this.paddle.render();\r\n        this.paddle2.render();\r\n        if (!Game.exiting) {\r\n            requestAnimationFrame(this.step.bind(this));\r\n        }\r\n    }\r\n    exit() {\r\n        Game.exiting = true;\r\n    }\r\n}\r\nGame.instance = null;\r\nGame.started = false;\r\nGame.exiting = false;\r\nexports.Game = Game;\r\n\n\n//# sourceURL=webpack:///./src/js/core/Game.ts?");

/***/ }),

/***/ "./src/js/core/Graphics.ts":
/*!*********************************!*\
  !*** ./src/js/core/Graphics.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Game_1 = __webpack_require__(/*! ./Game */ \"./src/js/core/Game.ts\");\r\nclass Graphics {\r\n    constructor() {\r\n        this.canvas = document.getElementById(\"canvas\");\r\n        this.ctx = this.canvas.getContext(\"2d\");\r\n    }\r\n    resize() {\r\n        this.canvas.width = Game_1.Game.width;\r\n        this.canvas.height = Game_1.Game.height;\r\n    }\r\n    rect(x, y, w, h, color) {\r\n        this.ctx.fillStyle = color;\r\n        this.ctx.fillRect(x, y, w, h);\r\n    }\r\n    circle(x, y, radius, startAngle, endAngle, anticlockwise) {\r\n        this.ctx.fillStyle = \"red\";\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise);\r\n        this.ctx.fill();\r\n    }\r\n    clear() {\r\n        this.ctx.clearRect(0, 0, Game_1.Game.width, Game_1.Game.height);\r\n    }\r\n}\r\nexports.Graphics = Graphics;\r\n\n\n//# sourceURL=webpack:///./src/js/core/Graphics.ts?");

/***/ }),

/***/ "./src/js/core/Networking.ts":
/*!***********************************!*\
  !*** ./src/js/core/Networking.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst neffos = __webpack_require__(/*! neffos.js */ \"./node_modules/neffos.js/dist/neffos.js\");\r\nconst Game_1 = __webpack_require__(/*! ./Game */ \"./src/js/core/Game.ts\");\r\nclass Networking {\r\n    static init() {\r\n        Networking.events = new Map();\r\n        Networking.events.set(\"_OnNamespaceConnected\", (c, msg) => {\r\n            if (c.conn.wasReconnected()) {\r\n                Game_1.Game.conn = c;\r\n            }\r\n            return null;\r\n        });\r\n        Networking.events.set(\"input\", (c, msg) => {\r\n            const playerInputs = JSON.parse(msg.Body);\r\n            // console.log(playerInputs)\r\n            for (const [key, p] of Object.entries(playerInputs)) {\r\n                const paddle = p;\r\n                if (key === c.conn.ID) {\r\n                    const currentPlayer = playerInputs[c.conn.ID];\r\n                    if (currentPlayer.player === 1) {\r\n                        Game_1.Game.paddle.y = currentPlayer.y - Game_1.Game.paddleHeight / 2;\r\n                    }\r\n                    else if (paddle.player === 2) {\r\n                        Game_1.Game.paddle2.y = currentPlayer.y - Game_1.Game.paddleHeight / 2;\r\n                    }\r\n                    // console.log(currentPlayer.y)\r\n                }\r\n                else {\r\n                    if (paddle.player === 1) {\r\n                        Game_1.Game.paddle.y = paddle.y - Game_1.Game.paddleHeight / 2;\r\n                    }\r\n                    else if (paddle.player === 2) {\r\n                        Game_1.Game.paddle2.y = paddle.y - Game_1.Game.paddleHeight / 2;\r\n                    }\r\n                }\r\n            }\r\n            return null;\r\n        });\r\n    }\r\n    static connect() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const conn = yield neffos.dial(Networking.wsURL, { default: Networking.events }, {\r\n                reconnect: 5000,\r\n            });\r\n            return conn.connect(\"default\");\r\n        });\r\n    }\r\n}\r\nNetworking.scheme = document.location.protocol === \"https:\" ? \"wss\" : \"ws\";\r\nNetworking.port = \":8081\";\r\nNetworking.wsURL = Networking.scheme + \"://localhost\" + document.location.hostname + Networking.port;\r\nexports.Networking = Networking;\r\n\n\n//# sourceURL=webpack:///./src/js/core/Networking.ts?");

/***/ }),

/***/ "./src/js/input/Mouse.ts":
/*!*******************************!*\
  !*** ./src/js/input/Mouse.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Game_1 = __webpack_require__(/*! ../core/Game */ \"./src/js/core/Game.ts\");\r\nconst Vector_1 = __webpack_require__(/*! ../util/Vector */ \"./src/js/util/Vector.ts\");\r\nclass Mouse {\r\n    static init() {\r\n        Mouse.position = new Vector_1.Vector(0, 0);\r\n        Mouse.positionNext = new Vector_1.Vector(0, 0);\r\n        Game_1.Game.root.addEventListener(\"mousemove\", (e) => {\r\n            Mouse.setNextMouseTo(e.pageX, e.pageY);\r\n            this.start = true;\r\n        });\r\n    }\r\n    static update() {\r\n        this.position = this.positionNext;\r\n    }\r\n    static get x() { return this.position.x; }\r\n    static get y() { return this.position.y; }\r\n    static get pos() { return this.positionNext; }\r\n    static get startedMoving() { return this.start; }\r\n    static setNextMouseTo(pageX, pageY) {\r\n        const screen = Game_1.Game.graphics.canvas.getBoundingClientRect();\r\n        Mouse.positionNext = new Vector_1.Vector(pageX - screen.left - Game_1.Game.root.scrollLeft, pageY - screen.top - Game_1.Game.root.scrollTop);\r\n    }\r\n}\r\nexports.Mouse = Mouse;\r\n\n\n//# sourceURL=webpack:///./src/js/input/Mouse.ts?");

/***/ }),

/***/ "./src/js/util/Vector.ts":
/*!*******************************!*\
  !*** ./src/js/util/Vector.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nclass Vector {\r\n    constructor(x, y) {\r\n        this.x = 0;\r\n        this.y = 0;\r\n        if (x !== undefined) {\r\n            this.x = x;\r\n        }\r\n        if (y !== undefined) {\r\n            this.y = y;\r\n        }\r\n    }\r\n    set(x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    }\r\n    copy(v) {\r\n        this.x = v.x;\r\n        this.y = v.y;\r\n        return this;\r\n    }\r\n    add(v) {\r\n        this.x += v.x;\r\n        this.y += v.y;\r\n        return this;\r\n    }\r\n    sub(v) {\r\n        this.x -= v.x;\r\n        this.y -= v.y;\r\n        return this;\r\n    }\r\n    mult(v) {\r\n        this.x *= v.x;\r\n        this.y *= v.y;\r\n        return this;\r\n    }\r\n    div(v) {\r\n        this.x /= v.x;\r\n        this.y /= v.y;\r\n        return this;\r\n    }\r\n    scale(s) {\r\n        this.x *= s;\r\n        this.y *= s;\r\n        return this;\r\n    }\r\n    clone() {\r\n        return new Vector(this.x, this.y);\r\n    }\r\n    get length() {\r\n        return Math.sqrt((this.x * this.x) + (this.y * this.y));\r\n    }\r\n    get angle() {\r\n        return Math.atan2(this.y, this.x);\r\n    }\r\n    get normal() {\r\n        const dist = this.length;\r\n        return new Vector(this.x / dist, this.y / dist);\r\n    }\r\n    normalize(length = 1) {\r\n        const dist = this.length;\r\n        this.x = (this.x / dist) * length;\r\n        this.y = (this.y / dist) * length;\r\n        return this;\r\n    }\r\n}\r\nexports.Vector = Vector;\r\n\n\n//# sourceURL=webpack:///./src/js/util/Vector.ts?");

/***/ })

/******/ });